Completed:
find-all, allows for specifying the number of solutions to search for
    solution-storage, every solution that's found gets added to an instance vector of solutions
add-pthreads, split up the initial grid into sections, have pthreads scan each section, use locks to
    count total number of solutions found across threads, store solutions in each thread's PuzzleSolver
    instance, merge the solutions into a final solutions vector, display the results
    also remove display from recursiveSolver, maybe replace with storeSolutions

Next up: pthread-depth, specify depth for thread splitting for all depths. implement as vector of ints,
    pass to solver alongside pieces vector

Future plans:
pthread-depth, decide whether to replace all instances of numSolutions and numThreads with the global macro
pthread-depth, double check that all function calls use the right parameters
pthread-depth, analyze where I should put the check within thread_recursiveSolver for whether it's 
    reached a sufficient number of solutions, base it on the impact it has on the performance.
    benchmark update will be useful for this
eliminate-final-recursion, potentially add a check if you've just placed the last piece, so that
    instead of recursing, you just do the finished logic right there in the same iteration
    no need to reach depth 9, just detect that depth 8 == pieces.size() - 1 and that we've just 
    successfully put the last piece down.
pthread-timer, add the ability to easily compare solving with pthreads vs without. possible use a flag
    using macros or something to enable/disable multithreading
readme, add proper README.md file
benchmark, add more comprehensive benchmark capabilities (auto-run multiple times with/without multithreading, 
    auto-run with different thread counts, without multithreading)
test-suite, add a bunch of tests to run on
bottleneck-identifier, figure out how to add functionality that gives information on how much time/power
    is spent on different parts of the program/code, so that I can identify bottlenecks